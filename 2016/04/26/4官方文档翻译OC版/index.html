<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="转载请注明出处注:本文主要内容来自于reactivecocoa官方文档参考文献
介绍ReactiveCocoa (RAC) 是一个Cocoa框架，受Functional Reactive Programming启发。它提供Api合成变换（composing and transforming）随着时间改变的数据流。ReactiveCocoa来源于functional reactive program">
<meta property="og:type" content="article">
<meta property="og:title" content="史上最全的 reactivecocoa 4">
<meta property="og:url" content="http://yoursite.com/2016/04/26/4官方文档翻译OC版/index.html">
<meta property="og:site_name" content="翁闻宇的技术博客">
<meta property="og:description" content="转载请注明出处注:本文主要内容来自于reactivecocoa官方文档参考文献
介绍ReactiveCocoa (RAC) 是一个Cocoa框架，受Functional Reactive Programming启发。它提供Api合成变换（composing and transforming）随着时间改变的数据流。ReactiveCocoa来源于functional reactive program">
<meta property="og:updated_time" content="2016-04-26T08:58:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="史上最全的 reactivecocoa 4">
<meta name="twitter:description" content="转载请注明出处注:本文主要内容来自于reactivecocoa官方文档参考文献
介绍ReactiveCocoa (RAC) 是一个Cocoa框架，受Functional Reactive Programming启发。它提供Api合成变换（composing and transforming）随着时间改变的数据流。ReactiveCocoa来源于functional reactive program">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 史上最全的 reactivecocoa 4 | 翁闻宇的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">翁闻宇的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">翁闻宇只是个会敲几行代码的老师而已</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                史上最全的 reactivecocoa 4
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-26T11:50:27+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/26/4官方文档翻译OC版/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/26/4官方文档翻译OC版/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="wengwenyu.com">转载请注明出处</a><br>注:<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">本文主要内容来自于reactivecocoa官方文档</a><br>参考文献</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ReactiveCocoa (RAC) 是一个Cocoa框架，受<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">Functional Reactive Programming</a>启发。它提供Api合成变换（composing and transforming）随着时间改变的数据流。<br><br>ReactiveCocoa来源于functional reactive programming(Input and Output)。<br>区别于使用不断变化修改的变量，RAC提供了“事件流”，通过 Signal 和 SignalProducer 类型来表示, 它们随着时间发送值。<br>事件流统一了Cocoa用于事件和异步处理的常用模式，包括：</p>
<ul>
<li>委托方法</li>
<li>回调blocks</li>
<li>通知</li>
<li>控件的actions和响应事件链</li>
<li>Futures and promises</li>
<li>Key-value observing (KVO)</li>
</ul>
<p>因为这些不同的机制能够用一种相同的方式处理，可以很容易的声明成链（chain）并且把它们联合在一起，用更少的代码和状态连接它们。</p>
<h1 id="基本操作符-一"><a href="#基本操作符-一" class="headerlink" title="基本操作符(一)"></a>基本操作符(一)</h1><blockquote>
<p>注意本文所提的『操作符』，指的是操作signals和signal producers的函数，不是传统编程语言里的操作符。换句话说，这些是用于处理事件流的基本元素。<br>本文将用事件流(event stream)指代Signal和SignalProducer。当有分歧时，会单独指明类型。</p>
</blockquote>
<ul>
<li>基本操作符(一)将先介绍：observe、on、lift、map、filter、reduce 六个操作符。</li>
</ul>
<h2 id="对事件流产生副作用-Performing-side-effects-with-event-streams"><a href="#对事件流产生副作用-Performing-side-effects-with-event-streams" class="headerlink" title="对事件流产生副作用(Performing side effects with event streams)"></a>对事件流产生副作用(Performing side effects with event streams)</h2><h3 id="观察-Observation"><a href="#观察-Observation" class="headerlink" title="观察 (Observation)"></a>观察 (Observation)</h3><p>Signals可以通过 observe函数进行观察。参数是一个 Observer。可以观察到这个signal将来每次发送的事件。<br><br>这样当有 Next, Failed, Completed 和 Interrupted事件发生时就会触发这些回调。<br><br>你不必观察所有类型，也可以只关注某个你关心的事件。</p>
<h3 id="注入影响-Injecting-effects"><a href="#注入影响-Injecting-effects" class="headerlink" title="注入影响 (Injecting effects)"></a>注入影响 (Injecting effects)</h3><p>可以通过 on来观察 SignalProducer，即使没有人订阅也会被触发。<br>和 observe相似，也可以只观察你关注的某个事件。<br>需要提到的是 producer要started后才会触发。</p>
<h2 id="操作符合成-Operator-composition"><a href="#操作符合成-Operator-composition" class="headerlink" title="操作符合成(Operator composition)"></a>操作符合成(Operator composition)</h2><h3 id="向上迁移"><a href="#向上迁移" class="headerlink" title="向上迁移"></a>向上迁移</h3><p> Signal的操作符可以通过 lift函数向上迁移以在SignalProducers上使用。<br>这样会产生一个新的SignalProducer，然后将操作符应用到每个由它产生的Signal中。</p>
<h3 id="转换事件流-Transforming-event-streams"><a href="#转换事件流-Transforming-event-streams" class="headerlink" title="转换事件流(Transforming event streams)"></a>转换事件流(Transforming event streams)</h3><p>以下这些操作符会将事件流转换成一个新的事件流。</p>
<h3 id="映射-Mapping"><a href="#映射-Mapping" class="headerlink" title="映射(Mapping)"></a>映射(Mapping)</h3><p>map用于将一个事件流的值操作后的结果产生一个新的事件流。</p>
<h3 id="过滤-Filtering"><a href="#过滤-Filtering" class="headerlink" title="过滤(Filtering)"></a>过滤(Filtering)</h3><p>filter函数可以按照之前预设的条件过滤掉不满足的值。</p>
<h3 id="聚集-Aggregating"><a href="#聚集-Aggregating" class="headerlink" title="聚集(Aggregating)"></a>聚集(Aggregating)</h3><p> reduce将事件里的值聚集后组合成一个值。要注意的是最后算出来的值直到输入的流完成后才会被发送出去。</p>
<h1 id="基本运算符（二）"><a href="#基本运算符（二）" class="headerlink" title="基本运算符（二）"></a>基本运算符（二）</h1><p>接下来主要介绍:combineLatest、zip、flatten( .Merge, .Concat, .Latest)、flatMapError、retry、mapError、promoteErrors 操作符。</p>
<h2 id="组合事件流"><a href="#组合事件流" class="headerlink" title="组合事件流"></a>组合事件流</h2><h3 id="按照最新的值组合"><a href="#按照最新的值组合" class="headerlink" title="按照最新的值组合"></a>按照最新的值组合</h3><p> combineLatest函数可以把几个事件流最新的值组合成一个新的事件流。<br>合成后的新事件流只有在收到每个合成流的至少一个值后才会发送出去。接着就会把每个流的最新的值一起输出。</p>
<h3 id="Zipping（拉链）"><a href="#Zipping（拉链）" class="headerlink" title="Zipping（拉链）"></a>Zipping（拉链）</h3><p> zip将两个（或者多个）事件流的值成对组合。就像拉链一样。将每个事件流的值按照索引顺序组合输出。意味着如果是一个流的第N个元素，一定要等到另外一个流第N值也收到才会一起组合发出。 zipWith操作符也是同样的工作模式。</p>
<h3 id="压平信号产生源-Flattening-producers"><a href="#压平信号产生源-Flattening-producers" class="headerlink" title="压平信号产生源(Flattening producers)"></a>压平信号产生源(Flattening producers)</h3><p> flatten 将一个事件流里的事件流变成一个单一的事件流。新的事件流的值按照指定的策略(FlattenStrategy)由内部的事件流的值组成。<br>被压平的值按照会变成外层的流的类型。比如：一个SignalProducers里的Signal，被flatten后的类型是SignalProducers。简单的说就是merge按照时间顺序组成，concat则是按照里面整个流顺序组合。latest是只记录最近一次过来的值的那个流。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p> .Merge 策略将每个流的值立刻组合输出。无论内部还是外层的流如果收到失败就终止。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p> .Concat 策略是将内部的SignalProducer排序。外层的producer是马上被started。随后的producer直到前一个发送完成后才会start。一有失败立即传到外层。</p>
<h3 id="转向最新的流"><a href="#转向最新的流" class="headerlink" title="转向最新的流"></a>转向最新的流</h3><p> .Latest只接收最新进来的那个流的值。</p>
<h3 id="处理失败"><a href="#处理失败" class="headerlink" title="处理失败"></a>处理失败</h3><p> flatMapError捕捉一个由SignalProducer产生的失败，然后产生一个新的SignalProducer代替。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p> retry用于按照指定次数，在失败时重启SignalProducer。如果按照指定次数还没有成功，就会输出失败。</p>
<h3 id="映射错误-Mapping-errors"><a href="#映射错误-Mapping-errors" class="headerlink" title="映射错误 (Mapping errors)"></a>映射错误 (Mapping errors)</h3><p> mapError会将事件流里的任何一个失败映射成一个新的错误。</p>
<h3 id="产生（Promote）"><a href="#产生（Promote）" class="headerlink" title="产生（Promote）"></a>产生（Promote）</h3><p>promoteErrors 可以在一个正常的流里产生一个错误，类似throw。</p>
<h1 id="框架组成介绍"><a href="#框架组成介绍" class="headerlink" title="框架组成介绍"></a>框架组成介绍</h1><h2 id="事件：Events"><a href="#事件：Events" class="headerlink" title="事件：Events"></a>事件：Events</h2><p>一个事件, 用 Event类型表示, 表示某些事情已经发生。 在RAC中事件是传播（center-piece of communication）的核心。 一个事件可能是button的一次点击，从API返回的一些信息，一个错误的发生，或者一个长时间操作完成了。无论如何，一些东西产生事件，然后通过signal发送给每个订阅这个signal的观察者。</p>
<p> Event是一个枚举类型，可能有四种值（Next中有值，其他三种表示结束）: <br></p>
<ul>
<li>Next代表有一个新的值从源产生。</li>
<li>Failed说明在信号源完成前发生了一个错误。事件会被当做一个类型为 ErrorType的参数，一种在事件中声明过的表示已知错误的类型。如果这个错误没有被声明许可过，可以用 NoError表示。</li>
<li>Completed说明事件已经成功结束。不会再有值发送出来。</li>
<li>Interrupted说明事件被取消了，意味着操作既没有成功也没有失败。</li>
</ul>
<h2 id="信号：Signals"><a href="#信号：Signals" class="headerlink" title="信号：Signals"></a>信号：Signals</h2><p>一个信号, 用  Signal类型表示,是一连串随着时间发出的可以被观察的事件。<br><br>信号通常用来表示事件流正在发出，比如通知，用户的输入等。每当动作被执行或者数据已经接受，事件们就会通过signal发出，signal会把它们推送给每个观察者。所有的观察者都会同时接受到事件。<br><br>用户如果想要接收它们的事件必须observe（观察）这个signal。观察一个信号不会触发其他副作用。换句话说，事件是源驱动，基于推送，观察者在整个生命周期里不会受到到任何影响。当观察一个信号时，用户只能按照顺序处理信号里的事件。不能随意访问信号里的事件。<br><br>信号可以被操作符操作。常用的操作一个信号的有filter，map和reduce，zip可以一次处理多个信号源。操作符只能在Next事件中才能使用。<br><br>信号的整个生命周期有一组Next事件组成，最后是一个终结事件，可能是Failed, Completed, 或者Interrupted中的任一个。终结事件没有被包含在事件的值里，他们需要被单独处理。</p>
<h2 id="管道：Pipes"><a href="#管道：Pipes" class="headerlink" title="管道：Pipes"></a>管道：Pipes</h2><p>一个管道，通过 Signal.pipe()创建。一个可以被手动控制的信号。<br><br>这个方法返回一个信号和一个observer。可以控制信号发送事件给观察者。这个在将非RAC的代码转变到信号世界里特别有用。<br><br>比如，可以不用在block的回调里处理业务逻辑，将blocks简化成发送事件给观察者。同时信号可以被返回，隐藏回调里的具体实现。</p>
<h2 id="信号生产者：Signal-Producers"><a href="#信号生产者：Signal-Producers" class="headerlink" title="信号生产者：Signal Producers"></a>信号生产者：Signal Producers</h2><p>一个信号生产者,以  SignalProducer类型表示,创建信号并且产生副作用。<br>可以用来表示一组操作或者任务，比如网络请求，每次 start()调用后会创建一个新的操作，允许发起者观察结果。通过 startWithSignal()可以访问到产生的信号，允许被多次观察。<br>因为 start()这种行为的不同，每次从同一个信号生产者可能会得到不同顺序或者版本的事件，甚至整个流可能完全不同。不像一个普通的信号，直到有一个观察者被添加才会开始启动，每次都会为新添加的观察者重新工作一次。<br><br>开启一个信号生产者会返回一个 disposable，用了中断或者取消（interrupt/cancel）这个信号生产者的工作。<br><br>和信号一样，信号生产者可以被操作符比如map，filter等操作。每个信号的操作符都可以通过“lifted”迁移后在信号生产者上使用。而且，还有几个特有的操作符用了控制工作什么时候开始和怎么运行，比如 times。</p>
<h2 id="缓冲：Buffers"><a href="#缓冲：Buffers" class="headerlink" title="缓冲：Buffers"></a>缓冲：Buffers</h2><p>一个缓冲通过  SignalProducer.buffer() 创建,是一个事件的队列（通常指定数量），当新信号产生时，会重新执行队列里的事件。<br><br>和 pipe相似，这个方法返回一个观察者。每个发给这个观察者的事件会被加入队列。如果这个缓冲区已经达到创建时预定的数量，当新的事件发来时，最早的一个会被移出队列。</p>
<h2 id="观察者：Observers"><a href="#观察者：Observers" class="headerlink" title="观察者：Observers"></a>观察者：Observers</h2><p>Observer是指任何等待从信号中接收事件的东西。</p>
<p>Observers可以通过 Signal.observe或者 SignalProducer.start隐式获得。</p>
<h2 id="动作：Actions"><a href="#动作：Actions" class="headerlink" title="动作：Actions"></a>动作：Actions</h2><p>动作用  Action类型表示，指当有输入时会做一些工作。当动作执行时，会有0个或者多个值输出；或者会产生一个失败。</p>
<p>Action用来处理用户交互时做一些处理很方便，比如当一个按钮点击时这种动作。Action也可以和一个属性自动关联disabled。比如当一个UI控件的关联Action被设置成disabled时，这个控件也会disabled。</p>
<p>为了和NSControl和UIControl交互，RAC提供了 CocoaAction类型可以桥接到OC下使用</p>
<h2 id="属性：Properties"><a href="#属性：Properties" class="headerlink" title="属性：Properties"></a>属性：Properties</h2><p>一个属性表现为  PropertyType协议（protocol）, 保存一个值，并且会将将来每次值的变化通知给观察者们。</p>
<p>property的当前值可以通过获取 value获得。 producer返回一个会一直发送值变化信号生成者（signal producer ），</p>
<p> &lt;~运算符是提供了几种不同的绑定属性的方式。注意这里绑定的属性必须是 MutablePropertyType类型的。</p>
<ul>
<li>property &lt;~ signal 将一个属性和信号绑定在一起，属性的值会根据信号送过来的值刷新。</li>
<li>property &lt;~ producer 会启动这个producer，并且属性的值也会随着这个产生的信号送过来的值刷新。</li>
<li>property &lt;~ otherProperty将一个属性和另一个属性绑定在一起，这样这个属性的值会随着源属性的值变化而变化。<br>DynamicProperty 类型用于桥接OC的要求KVC或者KVO的API，比如 NSOperation。要提醒的是大部分AppKit和UIKit的属性都不支持KVO，所以要观察它们值的变化需要通过其他的机制。相比 DynamicProperty要优先使用  MutablePropertyType类型。</li>
</ul>
<h2 id="销毁：Disposables"><a href="#销毁：Disposables" class="headerlink" title="销毁：Disposables"></a>销毁：Disposables</h2><p>disposable表现为 Disposable 协议,用于内存管理和释放销毁。</p>
<p>当你启动一个signal producer，一个disposable会被返回。可以用于被调起者取消已经启动的signal producer（比如后台线程的处理，网络请求等），清除临时资源，发送一个最终的 Interrupted事件给它创建的信号。</p>
<p>观察一个信号也会返回一个disposable。调用后就不会再收到这个信号发过来变化的值，但是这对信号本身不会产生影响。</p>
<h2 id="调度器：Schedulers"><a href="#调度器：Schedulers" class="headerlink" title="调度器：Schedulers"></a>调度器：Schedulers</h2><p>调度器，类型是 SchedulerType 协议, 是一个序列化的要被执行的任务队列或者是一组向外输出的结果。</p>
<p>信号和信号生成者可以按照安排好的次序发送事件到一个指定的 scheduler。信号生产者还可以在指定的调度器上被启动。</p>
<p>scheduler很像GCD，但是scheduler可以被销毁（通过Disposable），而且总是连续执行。由于 ImmediateScheduler 会引发异常, scheduler不提供同步的操作。这样可以避免出现死锁，还鼓励使用信号的操作符而不是blocking work。<br>scheduler也有点像NSOperationQueue, 但是scheduler不允许任务根据另一个调度器而改变顺序。</p>
<h1 id="设计指南-一-：事件的规范"><a href="#设计指南-一-：事件的规范" class="headerlink" title="设计指南(一)：事件的规范"></a>设计指南(一)：事件的规范</h1><h2 id="事件的规范"><a href="#事件的规范" class="headerlink" title="事件的规范"></a>事件的规范</h2><blockquote>
<p>事件是RAC的基础。signal和signal producer都发送事件，当一组事件集合在一起时我们称作“事件流”。事件流一定要按照下面的语法：<br><code>Next* (Interrupted | Failed | Completed)?</code><br><br>这说明一个事件流包括：</p>
</blockquote>
<ul>
<li>任意数量的 Next事件</li>
<li>可以跟一个终结事件，可以是Interrupted, Failed,或者Completed<br>在发送出一个终结事件后，不会再有其他事件发出。</li>
</ul>
<h2 id="Next：输出值或者表明事件发生"><a href="#Next：输出值或者表明事件发生" class="headerlink" title="Next：输出值或者表明事件发生"></a>Next：输出值或者表明事件发生</h2><p>Next事件里包含值。只有Next事件里才有值。因为事件流可以有任意多个Next，所以对于里面的值也没什么限制，除了值要保持同一类型。</p>
<p>比如，这个值可以是一个集合里的一个元素或者一个需要长时间处理的任务的进度。Next事件里的值也可以什么都不表示，比如，有时会用一个（）值表明有事件发生了，也没有特别说明是具体什么事件。</p>
<p>大部分的事件流操作符都是用于处理Next事件，因为里面的包含着来自signal或者producer的“有意义的数据”。</p>
<h2 id="Failure：和异常一样并且立即发送出去"><a href="#Failure：和异常一样并且立即发送出去" class="headerlink" title="Failure：和异常一样并且立即发送出去"></a>Failure：和异常一样并且立即发送出去</h2><p>Failed事件说明有些地方出错了，里面会包含具体的错误信息。Faile是致命的（fatal），会立即发送出去给用户好让用户处理。</p>
<p>失败（failure）的行为和异常很像，一旦发生就会跳过操作符，停止当前的操作。换句话说，当收到一个失败时，大部分的操作符会马上停止工作，然后把失败继续传下去。对于时间迁移操作符一样起作用，比如delay，也会立即传送下去。</p>
<p>因此，失败只应该在异常的时候使用。如果只是要其他操作符或者用户操作停止，用一个Next事件带上一个值表示结束更合适。</p>
<p>如果一个事件流不会失败，应该指明为 NoError类型作为参数，这样可以保证Failed失败不会被发送到事件流。</p>
<h2 id="Completion：表明成功"><a href="#Completion：表明成功" class="headerlink" title="Completion：表明成功"></a>Completion：表明成功</h2><p>当操作成功结束后，一个事件流发送Completed，或者声明这个流已经正常结束。</p>
<p>很多操作符通过控制Completed事件来缩短或者延长事件流的声明周期。</p>
<p>比如，take在接收到指定数量的值后就完成了，所以会提前终止这个流。从另一个方面来看，大部分的操作符会等待它接收的所有sigal或者producer都发送完Completed事件后才会发送Completed，因为必须通常正确的结果和所有的输入都有关。</p>
<h2 id="Interruption：取消执行中的工作通常立即发送出去"><a href="#Interruption：取消执行中的工作通常立即发送出去" class="headerlink" title="Interruption：取消执行中的工作通常立即发送出去"></a>Interruption：取消执行中的工作通常立即发送出去</h2><p>当事件流需要取消处理就会发送一个Interrupted事件。Interruption的状态介于成功和失败之间–操作并没有成功，也没有结束，也不代表着失败。</p>
<p>大部分的操作符会立即响应interruption，但是也有一些例外。比如，flatten操作符就会忽略在内部producer发出的Interrupted事件，因为内部的某个操作取消不应该取消整个单元的工作。</p>
<p>RAC会在disposal之前发送一个Interrupted事件，但是也可以手动发送。另外，自定义的操作符要保证会继续传送interruption给观察者。</p>
<h2 id="事件是线性发送的"><a href="#事件是线性发送的" class="headerlink" title="事件是线性发送的"></a>事件是线性发送的</h2><p>RAC保证所有在流里的事件都是线性依次发送。换句话说，观察者不会同时收到多个事件，即便事件是多线程同步产生的。</p>
<h2 id="事件不能递归"><a href="#事件不能递归" class="headerlink" title="事件不能递归"></a>事件不能递归</h2><p>就像RAC保证事件不会被同时接收到，它也保证不会递归的接收事件。因此，操作者和观察者没必要考虑重入。</p>
<p>如果正在处理一个从某信号发送的事件，此时一个事件通过另一个线程从这个信号发出，会导致死锁。这是因为递归信号通常是程序员的失误，确定性的死锁比不确定的资源竞争好。</p>
<p>如果确实需要一个递归的信号，递归的事件需要时间迁移，用一个操作符比如delay保证不会从一个正在运行的事件处理程序中发出。</p>
<h2 id="事件默认是同步发送的"><a href="#事件默认是同步发送的" class="headerlink" title="事件默认是同步发送的"></a>事件默认是同步发送的</h2><p>RAC不会隐式的引入并发和异步。操作者也许会接收一个scheduler，但是他们必须显式的被用户调用。</p>
<p>一个信号或者producer发送信号默认都是同步的，因为着当他们发送时观察者马上被调起。<br>这和NSNotificationCenter和UIControl事件的分发很像。</p>
<h1 id="Signal的规范"><a href="#Signal的规范" class="headerlink" title="Signal的规范"></a>Signal的规范</h1><p>一个信号是始终打开的流，流按照事件的规范。信号是一个引用类型。</p>
<p>因为每个信号都有自己的身份，换句话说，每个信号都有自己的生命周期，最终通常会终止。一旦被终止，信号不能被重启。</p>
<h2 id="信号一被实例化就开始工作"><a href="#信号一被实例化就开始工作" class="headerlink" title="信号一被实例化就开始工作"></a>信号一被实例化就开始工作</h2><p>Signal.init立即就会执行传递过来的闭包。意味着副作用可能在初始化器返回前就发生。</p>
<p>也可能在初始化器返回前就发送事件。然而，因为这个时候任何观察者都不能被添加，这个时候发出的事件都是不会被接收到。</p>
<h2 id="观察一个信号不会有副作用"><a href="#观察一个信号不会有副作用" class="headerlink" title="观察一个信号不会有副作用"></a>观察一个信号不会有副作用</h2><p> 当一个信号的观察者被添加或者被移除时，和信号关联的操作不会被启动或者停止。所以观察方法不会有副作用。</p>
<p>一个信号的副作用只能通过一个终结事件来停止。</p>
<h2 id="同一个信号的所有观察者同时按照相同顺序接收到事件"><a href="#同一个信号的所有观察者同时按照相同顺序接收到事件" class="headerlink" title="同一个信号的所有观察者同时按照相同顺序接收到事件"></a>同一个信号的所有观察者同时按照相同顺序接收到事件</h2><p>因为观察行为不会有副作用，一个信号不会为不同的观察者自定义不同的事件。<br>当一个事件从信号发出时，它会被同步的分发给所有观察者，这个机制和NSNotificationCenter发送通知有点像。</p>
<p>换句话说，不存在不同的观察者对应不同的事件流。所有的观察者看到的都是同一个事件流。</p>
<p>这条规则只有一种意外情况：在一个信号终止后添加一个观察者会产生一个Interrupted事件发送给这个观察者。</p>
<h2 id="信号会一直被保持直到所有观察者都被释放"><a href="#信号会一直被保持直到所有观察者都被释放" class="headerlink" title="信号会一直被保持直到所有观察者都被释放"></a>信号会一直被保持直到所有观察者都被释放</h2><p>即使信号源（caller）不再有一个指针指向信号（does not maintain a reference）：</p>
<p>Signal.init创建的信号会一直存在直到生成器闭包（generator closure）释放了作为参数的观察者<br>Signal.pipe创建的信号会一直存在直到它返回的观察者被释放<br>这保证了和信号关联的长耗时的工作不会被提前销毁。</p>
<p>注意一下，可以在收到终结事件收到前提前释放信号。但是应该避免这么做，这会导致内存泄露，但是有时为了让终结不可用会这么做。</p>
<h2 id="终止事件清除信号相关的资源"><a href="#终止事件清除信号相关的资源" class="headerlink" title="终止事件清除信号相关的资源"></a>终止事件清除信号相关的资源</h2><p>当一个终结事件从信号发出，所有的观察者都会被释放，所有用于产生事件的资源都应该被清除。</p>
<p>最简单的保证正确的清楚资源是利用生成器闭包（generator closure）返回的disposable，当终止发生时它会被处理。disposable要负责释放资源，关闭文件句柄，取消网络请求，或者其他任何和工作想关联的东西。</p>
<h2 id="SignalProducer的规范"><a href="#SignalProducer的规范" class="headerlink" title="SignalProducer的规范"></a>SignalProducer的规范</h2><p>一个信号生产者（signal producer）就像一份创造信号的食谱。信号生产者不会自己开始工作，在生成一个信号后开始工作。</p>
<p>信号生产者就是一份声明怎么创建信号，是值类型，所以没有内存管理的事情要担心。</p>
<h2 id="信号生成者根据创建信号的要求开始工作"><a href="#信号生成者根据创建信号的要求开始工作" class="headerlink" title="信号生成者根据创建信号的要求开始工作"></a>信号生成者根据创建信号的要求开始工作</h2><p> start和  startWithSignal方法会都会生成一个信号（隐式和显式）。在初始化信号后，传递给 SignalProducer.init的闭包会被执行,在有观察者添加后开启事件流。</p>
<p>虽然生产者自己不负责工作的执行，但是我们也会说“starting”和“canceling” 一个生产者。这两个词指产生一个要开始工作的信号，和释放那个信号以停止工作。</p>
<p>一个生产者可以被开始很多次，相关联的工作也会被执行同样多次。</p>
<h2 id="每个生产的信号可能在不同的时间发送不同的事件"><a href="#每个生产的信号可能在不同的时间发送不同的事件" class="headerlink" title="每个生产的信号可能在不同的时间发送不同的事件"></a>每个生产的信号可能在不同的时间发送不同的事件</h2><p>因为信号生产者根据需要开始工作，所以可能每次执行相关的观察者会不同，这些观察者可能接收到完全不同的事件顺序。</p>
<p>换句话说，每次生产者启动后生成的事件可能完全不同或者顺序完全不同。</p>
<p>尽管如此，每个信号生产者的每次执行后会按照事件的规范。（ReactiveCocoa 4 文档翻译:设计指南(一)：事件的规范）</p>
<h2 id="信号的操作符可以在迁移后使用在信号生产者上"><a href="#信号的操作符可以在迁移后使用在信号生产者上" class="headerlink" title="信号的操作符可以在迁移后使用在信号生产者上"></a>信号的操作符可以在迁移后使用在信号生产者上</h2><p>因为信号和信号生产者的紧密关系，利用 lift方法将使用在信号上的操作符向上迁移就可以使用在信号生产者上。</p>
<p> lift会将这个操作符的行为使用在每个信号生成者启动后产生的信号上。</p>
<h2 id="释放一个生产的信号会中断（interrupt）它"><a href="#释放一个生产的信号会中断（interrupt）它" class="headerlink" title="释放一个生产的信号会中断（interrupt）它"></a>释放一个生产的信号会中断（interrupt）它</h2><p>当一个信号生产者通过  startor  startWithSignal方法启动, 一个  Disposable会被自动创建并且传回。</p>
<p>释放它会中断信号生产者，从而取消未执行的工作并且发送一个Interrupted事件给所有观察者，也会释放所有在 SignalProducer.init时被添加进 CompositeDisposable的东西。<br>注意释放一个生产的信号不会影响到其他有这个信号生产者产生的信号。</p>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/21/ReactiveCocoa（RAC）最新版使用参考/" rel="next" title="ReactiveCocoa（RAC）最新版使用参考">
                <i class="fa fa-chevron-left"></i> ReactiveCocoa（RAC）最新版使用参考
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/04/26/4官方文档翻译OC版/"
     data-title="史上最全的 reactivecocoa 4"
     data-content=""
     data-url="http://yoursite.com/2016/04/26/4官方文档翻译OC版/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/04/26/4官方文档翻译OC版/"
           data-title="史上最全的 reactivecocoa 4" data-url="http://yoursite.com/2016/04/26/4官方文档翻译OC版/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://cexxz.img47.wal8.com/img47/543451_20160418123551/146095697081.jpg"
               alt="翁闻宇" />
          <p class="site-author-name" itemprop="name">翁闻宇</p>
          <p class="site-description motion-element" itemprop="description">如果世界变了，别忘了天空最初的颜色</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本操作符-一"><span class="nav-number">2.</span> <span class="nav-text">基本操作符(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对事件流产生副作用-Performing-side-effects-with-event-streams"><span class="nav-number">2.1.</span> <span class="nav-text">对事件流产生副作用(Performing side effects with event streams)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#观察-Observation"><span class="nav-number">2.1.1.</span> <span class="nav-text">观察 (Observation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注入影响-Injecting-effects"><span class="nav-number">2.1.2.</span> <span class="nav-text">注入影响 (Injecting effects)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符合成-Operator-composition"><span class="nav-number">2.2.</span> <span class="nav-text">操作符合成(Operator composition)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向上迁移"><span class="nav-number">2.2.1.</span> <span class="nav-text">向上迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换事件流-Transforming-event-streams"><span class="nav-number">2.2.2.</span> <span class="nav-text">转换事件流(Transforming event streams)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射-Mapping"><span class="nav-number">2.2.3.</span> <span class="nav-text">映射(Mapping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤-Filtering"><span class="nav-number">2.2.4.</span> <span class="nav-text">过滤(Filtering)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚集-Aggregating"><span class="nav-number">2.2.5.</span> <span class="nav-text">聚集(Aggregating)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本运算符（二）"><span class="nav-number">3.</span> <span class="nav-text">基本运算符（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组合事件流"><span class="nav-number">3.1.</span> <span class="nav-text">组合事件流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按照最新的值组合"><span class="nav-number">3.1.1.</span> <span class="nav-text">按照最新的值组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zipping（拉链）"><span class="nav-number">3.1.2.</span> <span class="nav-text">Zipping（拉链）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#压平信号产生源-Flattening-producers"><span class="nav-number">3.1.3.</span> <span class="nav-text">压平信号产生源(Flattening producers)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并"><span class="nav-number">3.1.4.</span> <span class="nav-text">合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接"><span class="nav-number">3.1.5.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转向最新的流"><span class="nav-number">3.1.6.</span> <span class="nav-text">转向最新的流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理失败"><span class="nav-number">3.1.7.</span> <span class="nav-text">处理失败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重试"><span class="nav-number">3.1.8.</span> <span class="nav-text">重试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射错误-Mapping-errors"><span class="nav-number">3.1.9.</span> <span class="nav-text">映射错误 (Mapping errors)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#产生（Promote）"><span class="nav-number">3.1.10.</span> <span class="nav-text">产生（Promote）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#框架组成介绍"><span class="nav-number">4.</span> <span class="nav-text">框架组成介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事件：Events"><span class="nav-number">4.1.</span> <span class="nav-text">事件：Events</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号：Signals"><span class="nav-number">4.2.</span> <span class="nav-text">信号：Signals</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道：Pipes"><span class="nav-number">4.3.</span> <span class="nav-text">管道：Pipes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号生产者：Signal-Producers"><span class="nav-number">4.4.</span> <span class="nav-text">信号生产者：Signal Producers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲：Buffers"><span class="nav-number">4.5.</span> <span class="nav-text">缓冲：Buffers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者：Observers"><span class="nav-number">4.6.</span> <span class="nav-text">观察者：Observers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动作：Actions"><span class="nav-number">4.7.</span> <span class="nav-text">动作：Actions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性：Properties"><span class="nav-number">4.8.</span> <span class="nav-text">属性：Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#销毁：Disposables"><span class="nav-number">4.9.</span> <span class="nav-text">销毁：Disposables</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度器：Schedulers"><span class="nav-number">4.10.</span> <span class="nav-text">调度器：Schedulers</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计指南-一-：事件的规范"><span class="nav-number">5.</span> <span class="nav-text">设计指南(一)：事件的规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事件的规范"><span class="nav-number">5.1.</span> <span class="nav-text">事件的规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Next：输出值或者表明事件发生"><span class="nav-number">5.2.</span> <span class="nav-text">Next：输出值或者表明事件发生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Failure：和异常一样并且立即发送出去"><span class="nav-number">5.3.</span> <span class="nav-text">Failure：和异常一样并且立即发送出去</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Completion：表明成功"><span class="nav-number">5.4.</span> <span class="nav-text">Completion：表明成功</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interruption：取消执行中的工作通常立即发送出去"><span class="nav-number">5.5.</span> <span class="nav-text">Interruption：取消执行中的工作通常立即发送出去</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件是线性发送的"><span class="nav-number">5.6.</span> <span class="nav-text">事件是线性发送的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件不能递归"><span class="nav-number">5.7.</span> <span class="nav-text">事件不能递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件默认是同步发送的"><span class="nav-number">5.8.</span> <span class="nav-text">事件默认是同步发送的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Signal的规范"><span class="nav-number">6.</span> <span class="nav-text">Signal的规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#信号一被实例化就开始工作"><span class="nav-number">6.1.</span> <span class="nav-text">信号一被实例化就开始工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察一个信号不会有副作用"><span class="nav-number">6.2.</span> <span class="nav-text">观察一个信号不会有副作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同一个信号的所有观察者同时按照相同顺序接收到事件"><span class="nav-number">6.3.</span> <span class="nav-text">同一个信号的所有观察者同时按照相同顺序接收到事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号会一直被保持直到所有观察者都被释放"><span class="nav-number">6.4.</span> <span class="nav-text">信号会一直被保持直到所有观察者都被释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终止事件清除信号相关的资源"><span class="nav-number">6.5.</span> <span class="nav-text">终止事件清除信号相关的资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SignalProducer的规范"><span class="nav-number">6.6.</span> <span class="nav-text">SignalProducer的规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号生成者根据创建信号的要求开始工作"><span class="nav-number">6.7.</span> <span class="nav-text">信号生成者根据创建信号的要求开始工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每个生产的信号可能在不同的时间发送不同的事件"><span class="nav-number">6.8.</span> <span class="nav-text">每个生产的信号可能在不同的时间发送不同的事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号的操作符可以在迁移后使用在信号生产者上"><span class="nav-number">6.9.</span> <span class="nav-text">信号的操作符可以在迁移后使用在信号生产者上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放一个生产的信号会中断（interrupt）它"><span class="nav-number">6.10.</span> <span class="nav-text">释放一个生产的信号会中断（interrupt）它</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翁闻宇</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wengwenyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
