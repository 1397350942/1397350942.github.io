<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="如果世界变了，别忘了天空最初的颜色">
<meta property="og:type" content="website">
<meta property="og:title" content="翁闻宇的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="翁闻宇的技术博客">
<meta property="og:description" content="如果世界变了，别忘了天空最初的颜色">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="翁闻宇的技术博客">
<meta name="twitter:description" content="如果世界变了，别忘了天空最初的颜色">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 翁闻宇的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">翁闻宇的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">翁闻宇只是个会敲几行代码的老师而已</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/18/hexo搭建方案（一）/" itemprop="url">
                  hexo搭建方案（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-18T08:30:01+08:00" content="2016-05-18">
              2016-05-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/18/hexo搭建方案（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/18/hexo搭建方案（一）/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><h2 id="安装nvm（Node-Version-Manager），Terminal中运行"><a href="#安装nvm（Node-Version-Manager），Terminal中运行" class="headerlink" title="安装nvm（Node Version Manager），Terminal中运行"></a>安装nvm（Node Version Manager），Terminal中运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.githubusercontent.com/creationix/nvm/v0.7.0/install.sh | sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会提示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; Close and reopen your terminal to start using NVM</span><br></pre></td></tr></table></figure>
<blockquote>
<p>退出Terminal重启后nvm命令才能生效。假如update失败，可能没有profile文件，touch一下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.bash_profile</span><br><span class="line">touch ~/.profile</span><br></pre></td></tr></table></figure>
<h2 id="使用nvm安装node-js："><a href="#使用nvm安装node-js：" class="headerlink" title="使用nvm安装node.js："></a>使用nvm安装node.js：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 0.10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下完后安装hexo，这一步时间比较长：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h2 id="然后找个文件初始化blog："><a href="#然后找个文件初始化blog：" class="headerlink" title="然后找个文件初始化blog："></a>然后找个文件初始化blog：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/git/blog  </span><br><span class="line">hexo init .</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<h3 id="update-更新hexo2版本后安装还需要执行："><a href="#update-更新hexo2版本后安装还需要执行：" class="headerlink" title="[update]更新hexo2版本后安装还需要执行："></a>[update]更新hexo2版本后安装还需要执行：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-ejs --save</span><br><span class="line">$ npm install hexo-renderer-stylus --save</span><br><span class="line">$ npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<h3 id="生成出的目录结构："><a href="#生成出的目录结构：" class="headerlink" title="生成出的目录结构："></a>生成出的目录结构：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── scripts</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h2 id="新建一篇文章："><a href="#新建一篇文章：" class="headerlink" title="新建一篇文章："></a>新建一篇文章：</h2><blockquote>
<p>hexo new mac下使用hexo搭建blog</p>
<h2 id="open-source-posts-mac下使用hexo搭建blog-md"><a href="#open-source-posts-mac下使用hexo搭建blog-md" class="headerlink" title="open source/_posts/mac下使用hexo搭建blog.md"></a>open source/_posts/mac下使用hexo搭建blog.md</h2></blockquote>
<h2 id="编辑md后生成html："><a href="#编辑md后生成html：" class="headerlink" title="编辑md后生成html："></a>编辑md后生成html：</h2><p>$ hexo generate<br>本地预览：<br>$ hexo server<br>=&gt; [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.</p>
<h1 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h1><p>github上建个respository，设置里设一下<br>在_config.yml中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: github</span><br><span class="line">repository: https://github.com/sunnyxx/blog-hexo.git</span><br></pre></td></tr></table></figure>
<p>然后执行：<br>$ hexo deploy</p>
<p>就行了，github会多一个branch，比octopress简单</p>
<p>参考文献：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://opiece.me/2015/04/09/hexo-guide/</span><br><span class="line">http://www.jianshu.com/p/465830080ea9</span><br><span class="line">http://www.jianshu.com/p/a2023a601ceb</span><br><span class="line">https://hexo.io/zh-cn/</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/06/配置Node-js开发环境-使用Atom实践/" itemprop="url">
                  配置Node.js开发环境--使用Atom实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-06T12:06:05+08:00" content="2016-05-06">
              2016-05-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/06/配置Node-js开发环境-使用Atom实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/06/配置Node-js开发环境-使用Atom实践/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装完-Atom-后需要安装一些插件"><a href="#安装完-Atom-后需要安装一些插件" class="headerlink" title="安装完 Atom 后需要安装一些插件"></a>安装完 Atom 后需要安装一些插件</h1><blockquote>
<p>Atom 自己去官方下载安装即可</p>
<ul>
<li>atom-ternjs 用于 Javascript 和 Node.js 的自动补全</li>
<li>script 用于一键运行程序<h2 id="自动补全插件"><a href="#自动补全插件" class="headerlink" title="自动补全插件"></a>自动补全插件</h2>Atom 上的 Javascript 自动补全主要依赖 atom-ternjs 插件，貌似没有什么其它更好的选择。（配合 autocomplete-plus 插件使用，Atom 默认已经安装。）<br><br>安装方法与安装其它插件无异，主要有三种选择：</li>
<li>1.图形界面<br>在 Atom 的 Settings &gt; Install 里搜索找到 atom-ternjs 并安装。<br>这种方法在国内需要科学上网。</li>
<li>2.命令行<br>apm install atom-ternjs   这种方法在国内也需要科学上网。</li>
<li>3.本地安装。<br><code>cd ~/.atom/packages<br>git clone git@github.com:tststs/atom-ternjs.git<br>cd atom-ternjs<br>npm install</code><h2 id="一键运行插件"><a href="#一键运行插件" class="headerlink" title="一键运行插件"></a>一键运行插件</h2>安装 script 插件，然后有两种方法可以一键运行/结束程序了：<br>1.Packages &gt; Script &gt; Run Script/Stop Script。<br>2.快捷键   运行 cmd+i   结束 ctrl + c<h2 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h2>atom-ternjs 插件对项目配置做了可视化，可以通过菜单来操作。<br>File &gt; Open 打开 Node.js 项目文件夹。</li>
</ul>
<p>Package &gt; Atom Ternjs &gt; Configure project</p>
</blockquote>
<p>Save &amp; Restart server 之后会在项目根目录生成 .tern-project 文件，该配置文件里常用字段：</p>
<p>字段名    含义<br>ecmaVersion    选择 ECMAScript 版本<br>libs    browser 表示原生 js 补全，jquery 代表 jQuery 补全<br>loadEagerly    指定加载解析的 js 文件<br>dontLoad    排除加载的文件<br>plugins    ternjs 使用的插件，配置的扩展补全的库等</p>
<p>目前插件的配置页面暂不支持 plugins 部分配置，需要手动配置。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/30/MAC电脑下node-js环境配置/" itemprop="url">
                  MAC电脑下node.js环境配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-30T11:07:29+08:00" content="2016-04-30">
              2016-04-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/30/MAC电脑下node-js环境配置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/30/MAC电脑下node-js环境配置/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一步，安装xcode"><a href="#第一步，安装xcode" class="headerlink" title="第一步，安装xcode"></a>第一步，安装xcode</h1><h1 id="第二步，安装包管理工具homebrew"><a href="#第二步，安装包管理工具homebrew" class="headerlink" title="第二步，安装包管理工具homebrew"></a>第二步，安装包管理工具homebrew</h1><blockquote>
<p><a href="http://brew.sh/" target="_blank" rel="external">http://brew.sh/</a><br>常用命令行</p>
</blockquote>
<ul>
<li>brew list   —列出已安装的软件</li>
<li>brew update   —更新Homebrew</li>
<li>brew home  *—用浏览器打开</li>
<li>brew info   *—显示软件内容信息</li>
<li>brew deps * — 显示包依赖</li>
<li>brew server *  —启动web服务器，可以通过浏览器访问<a href="http://localhost:4567/" target="_blank" rel="external">http://localhost:4567/</a> 来同网页来管理包</li>
<li>brew -h brew   —帮助</li>
<li>brew install + 软件名</li>
<li>brew upgrade + 软件名     更新某个具体软件</li>
<li>brew uninstall +软件名     删除某个具体软件</li>
</ul>
<blockquote>
<p>Press RETURN to continue or any other key to abort 当出现这个代码的时候赶紧回车输入密码，而不是傻等</p>
<h1 id="第三步，安装node-js"><a href="#第三步，安装node-js" class="headerlink" title="第三步，安装node.js"></a>第三步，安装node.js</h1><p>*brew install nodejs</p>
<h1 id="第四步，安装mongodb"><a href="#第四步，安装mongodb" class="headerlink" title="第四步，安装mongodb"></a>第四步，安装mongodb</h1><ul>
<li>brew install mongodb<h1 id="第五步，安装-redis"><a href="#第五步，安装-redis" class="headerlink" title="第五步，安装 redis"></a>第五步，安装 redis</h1></li>
<li>brew install redis</li>
</ul>
</blockquote>
<p>nodejs 安装小贴士：<br>本人是直接在官网下载软件包安装的，同时用淘宝镜像代替了npm，cnpm可以跟npm一样使用，在国内安装各种依赖包就快了。</p>
<blockquote>
<p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a></p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/26/4官方文档翻译OC版/" itemprop="url">
                  史上最全的 reactivecocoa 4
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-26T11:50:27+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/26/4官方文档翻译OC版/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/26/4官方文档翻译OC版/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="wengwenyu.com">转载请注明出处</a><br>注:<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">本文主要内容来自于reactivecocoa官方文档</a><br>参考文献</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ReactiveCocoa (RAC) 是一个Cocoa框架，受<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">Functional Reactive Programming</a>启发。它提供Api合成变换（composing and transforming）随着时间改变的数据流。<br><br>ReactiveCocoa来源于functional reactive programming(Input and Output)。<br>区别于使用不断变化修改的变量，RAC提供了“事件流”，通过 Signal 和 SignalProducer 类型来表示, 它们随着时间发送值。<br>事件流统一了Cocoa用于事件和异步处理的常用模式，包括：</p>
<ul>
<li>委托方法</li>
<li>回调blocks</li>
<li>通知</li>
<li>控件的actions和响应事件链</li>
<li>Futures and promises</li>
<li>Key-value observing (KVO)</li>
</ul>
<p>因为这些不同的机制能够用一种相同的方式处理，可以很容易的声明成链（chain）并且把它们联合在一起，用更少的代码和状态连接它们。</p>
<h1 id="基本操作符-一"><a href="#基本操作符-一" class="headerlink" title="基本操作符(一)"></a>基本操作符(一)</h1><blockquote>
<p>注意本文所提的『操作符』，指的是操作signals和signal producers的函数，不是传统编程语言里的操作符。换句话说，这些是用于处理事件流的基本元素。<br>本文将用事件流(event stream)指代Signal和SignalProducer。当有分歧时，会单独指明类型。</p>
</blockquote>
<ul>
<li>基本操作符(一)将先介绍：observe、on、lift、map、filter、reduce 六个操作符。</li>
</ul>
<h2 id="对事件流产生副作用-Performing-side-effects-with-event-streams"><a href="#对事件流产生副作用-Performing-side-effects-with-event-streams" class="headerlink" title="对事件流产生副作用(Performing side effects with event streams)"></a>对事件流产生副作用(Performing side effects with event streams)</h2><h3 id="观察-Observation"><a href="#观察-Observation" class="headerlink" title="观察 (Observation)"></a>观察 (Observation)</h3><p>Signals可以通过 observe函数进行观察。参数是一个 Observer。可以观察到这个signal将来每次发送的事件。<br><br>这样当有 Next, Failed, Completed 和 Interrupted事件发生时就会触发这些回调。<br><br>你不必观察所有类型，也可以只关注某个你关心的事件。</p>
<h3 id="注入影响-Injecting-effects"><a href="#注入影响-Injecting-effects" class="headerlink" title="注入影响 (Injecting effects)"></a>注入影响 (Injecting effects)</h3><p>可以通过 on来观察 SignalProducer，即使没有人订阅也会被触发。<br>和 observe相似，也可以只观察你关注的某个事件。<br>需要提到的是 producer要started后才会触发。</p>
<h2 id="操作符合成-Operator-composition"><a href="#操作符合成-Operator-composition" class="headerlink" title="操作符合成(Operator composition)"></a>操作符合成(Operator composition)</h2><h3 id="向上迁移"><a href="#向上迁移" class="headerlink" title="向上迁移"></a>向上迁移</h3><p> Signal的操作符可以通过 lift函数向上迁移以在SignalProducers上使用。<br>这样会产生一个新的SignalProducer，然后将操作符应用到每个由它产生的Signal中。</p>
<h3 id="转换事件流-Transforming-event-streams"><a href="#转换事件流-Transforming-event-streams" class="headerlink" title="转换事件流(Transforming event streams)"></a>转换事件流(Transforming event streams)</h3><p>以下这些操作符会将事件流转换成一个新的事件流。</p>
<h3 id="映射-Mapping"><a href="#映射-Mapping" class="headerlink" title="映射(Mapping)"></a>映射(Mapping)</h3><p>map用于将一个事件流的值操作后的结果产生一个新的事件流。</p>
<h3 id="过滤-Filtering"><a href="#过滤-Filtering" class="headerlink" title="过滤(Filtering)"></a>过滤(Filtering)</h3><p>filter函数可以按照之前预设的条件过滤掉不满足的值。</p>
<h3 id="聚集-Aggregating"><a href="#聚集-Aggregating" class="headerlink" title="聚集(Aggregating)"></a>聚集(Aggregating)</h3><p> reduce将事件里的值聚集后组合成一个值。要注意的是最后算出来的值直到输入的流完成后才会被发送出去。</p>
<h1 id="基本运算符（二）"><a href="#基本运算符（二）" class="headerlink" title="基本运算符（二）"></a>基本运算符（二）</h1><p>接下来主要介绍:combineLatest、zip、flatten( .Merge, .Concat, .Latest)、flatMapError、retry、mapError、promoteErrors 操作符。</p>
<h2 id="组合事件流"><a href="#组合事件流" class="headerlink" title="组合事件流"></a>组合事件流</h2><h3 id="按照最新的值组合"><a href="#按照最新的值组合" class="headerlink" title="按照最新的值组合"></a>按照最新的值组合</h3><p> combineLatest函数可以把几个事件流最新的值组合成一个新的事件流。<br>合成后的新事件流只有在收到每个合成流的至少一个值后才会发送出去。接着就会把每个流的最新的值一起输出。</p>
<h3 id="Zipping（拉链）"><a href="#Zipping（拉链）" class="headerlink" title="Zipping（拉链）"></a>Zipping（拉链）</h3><p> zip将两个（或者多个）事件流的值成对组合。就像拉链一样。将每个事件流的值按照索引顺序组合输出。意味着如果是一个流的第N个元素，一定要等到另外一个流第N值也收到才会一起组合发出。 zipWith操作符也是同样的工作模式。</p>
<h3 id="压平信号产生源-Flattening-producers"><a href="#压平信号产生源-Flattening-producers" class="headerlink" title="压平信号产生源(Flattening producers)"></a>压平信号产生源(Flattening producers)</h3><p> flatten 将一个事件流里的事件流变成一个单一的事件流。新的事件流的值按照指定的策略(FlattenStrategy)由内部的事件流的值组成。<br>被压平的值按照会变成外层的流的类型。比如：一个SignalProducers里的Signal，被flatten后的类型是SignalProducers。简单的说就是merge按照时间顺序组成，concat则是按照里面整个流顺序组合。latest是只记录最近一次过来的值的那个流。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p> .Merge 策略将每个流的值立刻组合输出。无论内部还是外层的流如果收到失败就终止。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p> .Concat 策略是将内部的SignalProducer排序。外层的producer是马上被started。随后的producer直到前一个发送完成后才会start。一有失败立即传到外层。</p>
<h3 id="转向最新的流"><a href="#转向最新的流" class="headerlink" title="转向最新的流"></a>转向最新的流</h3><p> .Latest只接收最新进来的那个流的值。</p>
<h3 id="处理失败"><a href="#处理失败" class="headerlink" title="处理失败"></a>处理失败</h3><p> flatMapError捕捉一个由SignalProducer产生的失败，然后产生一个新的SignalProducer代替。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p> retry用于按照指定次数，在失败时重启SignalProducer。如果按照指定次数还没有成功，就会输出失败。</p>
<h3 id="映射错误-Mapping-errors"><a href="#映射错误-Mapping-errors" class="headerlink" title="映射错误 (Mapping errors)"></a>映射错误 (Mapping errors)</h3><p> mapError会将事件流里的任何一个失败映射成一个新的错误。</p>
<h3 id="产生（Promote）"><a href="#产生（Promote）" class="headerlink" title="产生（Promote）"></a>产生（Promote）</h3><p>promoteErrors 可以在一个正常的流里产生一个错误，类似throw。</p>
<h1 id="框架组成介绍"><a href="#框架组成介绍" class="headerlink" title="框架组成介绍"></a>框架组成介绍</h1><h2 id="事件：Events"><a href="#事件：Events" class="headerlink" title="事件：Events"></a>事件：Events</h2><p>一个事件, 用 Event类型表示, 表示某些事情已经发生。 在RAC中事件是传播（center-piece of communication）的核心。 一个事件可能是button的一次点击，从API返回的一些信息，一个错误的发生，或者一个长时间操作完成了。无论如何，一些东西产生事件，然后通过signal发送给每个订阅这个signal的观察者。</p>
<p> Event是一个枚举类型，可能有四种值（Next中有值，其他三种表示结束）: <br></p>
<ul>
<li>Next代表有一个新的值从源产生。</li>
<li>Failed说明在信号源完成前发生了一个错误。事件会被当做一个类型为 ErrorType的参数，一种在事件中声明过的表示已知错误的类型。如果这个错误没有被声明许可过，可以用 NoError表示。</li>
<li>Completed说明事件已经成功结束。不会再有值发送出来。</li>
<li>Interrupted说明事件被取消了，意味着操作既没有成功也没有失败。</li>
</ul>
<h2 id="信号：Signals"><a href="#信号：Signals" class="headerlink" title="信号：Signals"></a>信号：Signals</h2><p>一个信号, 用  Signal类型表示,是一连串随着时间发出的可以被观察的事件。<br><br>信号通常用来表示事件流正在发出，比如通知，用户的输入等。每当动作被执行或者数据已经接受，事件们就会通过signal发出，signal会把它们推送给每个观察者。所有的观察者都会同时接受到事件。<br><br>用户如果想要接收它们的事件必须observe（观察）这个signal。观察一个信号不会触发其他副作用。换句话说，事件是源驱动，基于推送，观察者在整个生命周期里不会受到到任何影响。当观察一个信号时，用户只能按照顺序处理信号里的事件。不能随意访问信号里的事件。<br><br>信号可以被操作符操作。常用的操作一个信号的有filter，map和reduce，zip可以一次处理多个信号源。操作符只能在Next事件中才能使用。<br><br>信号的整个生命周期有一组Next事件组成，最后是一个终结事件，可能是Failed, Completed, 或者Interrupted中的任一个。终结事件没有被包含在事件的值里，他们需要被单独处理。</p>
<h2 id="管道：Pipes"><a href="#管道：Pipes" class="headerlink" title="管道：Pipes"></a>管道：Pipes</h2><p>一个管道，通过 Signal.pipe()创建。一个可以被手动控制的信号。<br><br>这个方法返回一个信号和一个observer。可以控制信号发送事件给观察者。这个在将非RAC的代码转变到信号世界里特别有用。<br><br>比如，可以不用在block的回调里处理业务逻辑，将blocks简化成发送事件给观察者。同时信号可以被返回，隐藏回调里的具体实现。</p>
<h2 id="信号生产者：Signal-Producers"><a href="#信号生产者：Signal-Producers" class="headerlink" title="信号生产者：Signal Producers"></a>信号生产者：Signal Producers</h2><p>一个信号生产者,以  SignalProducer类型表示,创建信号并且产生副作用。<br>可以用来表示一组操作或者任务，比如网络请求，每次 start()调用后会创建一个新的操作，允许发起者观察结果。通过 startWithSignal()可以访问到产生的信号，允许被多次观察。<br>因为 start()这种行为的不同，每次从同一个信号生产者可能会得到不同顺序或者版本的事件，甚至整个流可能完全不同。不像一个普通的信号，直到有一个观察者被添加才会开始启动，每次都会为新添加的观察者重新工作一次。<br><br>开启一个信号生产者会返回一个 disposable，用了中断或者取消（interrupt/cancel）这个信号生产者的工作。<br><br>和信号一样，信号生产者可以被操作符比如map，filter等操作。每个信号的操作符都可以通过“lifted”迁移后在信号生产者上使用。而且，还有几个特有的操作符用了控制工作什么时候开始和怎么运行，比如 times。</p>
<h2 id="缓冲：Buffers"><a href="#缓冲：Buffers" class="headerlink" title="缓冲：Buffers"></a>缓冲：Buffers</h2><p>一个缓冲通过  SignalProducer.buffer() 创建,是一个事件的队列（通常指定数量），当新信号产生时，会重新执行队列里的事件。<br><br>和 pipe相似，这个方法返回一个观察者。每个发给这个观察者的事件会被加入队列。如果这个缓冲区已经达到创建时预定的数量，当新的事件发来时，最早的一个会被移出队列。</p>
<h2 id="观察者：Observers"><a href="#观察者：Observers" class="headerlink" title="观察者：Observers"></a>观察者：Observers</h2><p>Observer是指任何等待从信号中接收事件的东西。</p>
<p>Observers可以通过 Signal.observe或者 SignalProducer.start隐式获得。</p>
<h2 id="动作：Actions"><a href="#动作：Actions" class="headerlink" title="动作：Actions"></a>动作：Actions</h2><p>动作用  Action类型表示，指当有输入时会做一些工作。当动作执行时，会有0个或者多个值输出；或者会产生一个失败。</p>
<p>Action用来处理用户交互时做一些处理很方便，比如当一个按钮点击时这种动作。Action也可以和一个属性自动关联disabled。比如当一个UI控件的关联Action被设置成disabled时，这个控件也会disabled。</p>
<p>为了和NSControl和UIControl交互，RAC提供了 CocoaAction类型可以桥接到OC下使用</p>
<h2 id="属性：Properties"><a href="#属性：Properties" class="headerlink" title="属性：Properties"></a>属性：Properties</h2><p>一个属性表现为  PropertyType协议（protocol）, 保存一个值，并且会将将来每次值的变化通知给观察者们。</p>
<p>property的当前值可以通过获取 value获得。 producer返回一个会一直发送值变化信号生成者（signal producer ），</p>
<p> &lt;~运算符是提供了几种不同的绑定属性的方式。注意这里绑定的属性必须是 MutablePropertyType类型的。</p>
<ul>
<li>property &lt;~ signal 将一个属性和信号绑定在一起，属性的值会根据信号送过来的值刷新。</li>
<li>property &lt;~ producer 会启动这个producer，并且属性的值也会随着这个产生的信号送过来的值刷新。</li>
<li>property &lt;~ otherProperty将一个属性和另一个属性绑定在一起，这样这个属性的值会随着源属性的值变化而变化。<br>DynamicProperty 类型用于桥接OC的要求KVC或者KVO的API，比如 NSOperation。要提醒的是大部分AppKit和UIKit的属性都不支持KVO，所以要观察它们值的变化需要通过其他的机制。相比 DynamicProperty要优先使用  MutablePropertyType类型。</li>
</ul>
<h2 id="销毁：Disposables"><a href="#销毁：Disposables" class="headerlink" title="销毁：Disposables"></a>销毁：Disposables</h2><p>disposable表现为 Disposable 协议,用于内存管理和释放销毁。</p>
<p>当你启动一个signal producer，一个disposable会被返回。可以用于被调起者取消已经启动的signal producer（比如后台线程的处理，网络请求等），清除临时资源，发送一个最终的 Interrupted事件给它创建的信号。</p>
<p>观察一个信号也会返回一个disposable。调用后就不会再收到这个信号发过来变化的值，但是这对信号本身不会产生影响。</p>
<h2 id="调度器：Schedulers"><a href="#调度器：Schedulers" class="headerlink" title="调度器：Schedulers"></a>调度器：Schedulers</h2><p>调度器，类型是 SchedulerType 协议, 是一个序列化的要被执行的任务队列或者是一组向外输出的结果。</p>
<p>信号和信号生成者可以按照安排好的次序发送事件到一个指定的 scheduler。信号生产者还可以在指定的调度器上被启动。</p>
<p>scheduler很像GCD，但是scheduler可以被销毁（通过Disposable），而且总是连续执行。由于 ImmediateScheduler 会引发异常, scheduler不提供同步的操作。这样可以避免出现死锁，还鼓励使用信号的操作符而不是blocking work。<br>scheduler也有点像NSOperationQueue, 但是scheduler不允许任务根据另一个调度器而改变顺序。</p>
<h1 id="设计指南-一-：事件的规范"><a href="#设计指南-一-：事件的规范" class="headerlink" title="设计指南(一)：事件的规范"></a>设计指南(一)：事件的规范</h1><h2 id="事件的规范"><a href="#事件的规范" class="headerlink" title="事件的规范"></a>事件的规范</h2><blockquote>
<p>事件是RAC的基础。signal和signal producer都发送事件，当一组事件集合在一起时我们称作“事件流”。事件流一定要按照下面的语法：<br><code>Next* (Interrupted | Failed | Completed)?</code><br><br>这说明一个事件流包括：</p>
</blockquote>
<ul>
<li>任意数量的 Next事件</li>
<li>可以跟一个终结事件，可以是Interrupted, Failed,或者Completed<br>在发送出一个终结事件后，不会再有其他事件发出。</li>
</ul>
<h2 id="Next：输出值或者表明事件发生"><a href="#Next：输出值或者表明事件发生" class="headerlink" title="Next：输出值或者表明事件发生"></a>Next：输出值或者表明事件发生</h2><p>Next事件里包含值。只有Next事件里才有值。因为事件流可以有任意多个Next，所以对于里面的值也没什么限制，除了值要保持同一类型。</p>
<p>比如，这个值可以是一个集合里的一个元素或者一个需要长时间处理的任务的进度。Next事件里的值也可以什么都不表示，比如，有时会用一个（）值表明有事件发生了，也没有特别说明是具体什么事件。</p>
<p>大部分的事件流操作符都是用于处理Next事件，因为里面的包含着来自signal或者producer的“有意义的数据”。</p>
<h2 id="Failure：和异常一样并且立即发送出去"><a href="#Failure：和异常一样并且立即发送出去" class="headerlink" title="Failure：和异常一样并且立即发送出去"></a>Failure：和异常一样并且立即发送出去</h2><p>Failed事件说明有些地方出错了，里面会包含具体的错误信息。Faile是致命的（fatal），会立即发送出去给用户好让用户处理。</p>
<p>失败（failure）的行为和异常很像，一旦发生就会跳过操作符，停止当前的操作。换句话说，当收到一个失败时，大部分的操作符会马上停止工作，然后把失败继续传下去。对于时间迁移操作符一样起作用，比如delay，也会立即传送下去。</p>
<p>因此，失败只应该在异常的时候使用。如果只是要其他操作符或者用户操作停止，用一个Next事件带上一个值表示结束更合适。</p>
<p>如果一个事件流不会失败，应该指明为 NoError类型作为参数，这样可以保证Failed失败不会被发送到事件流。</p>
<h2 id="Completion：表明成功"><a href="#Completion：表明成功" class="headerlink" title="Completion：表明成功"></a>Completion：表明成功</h2><p>当操作成功结束后，一个事件流发送Completed，或者声明这个流已经正常结束。</p>
<p>很多操作符通过控制Completed事件来缩短或者延长事件流的声明周期。</p>
<p>比如，take在接收到指定数量的值后就完成了，所以会提前终止这个流。从另一个方面来看，大部分的操作符会等待它接收的所有sigal或者producer都发送完Completed事件后才会发送Completed，因为必须通常正确的结果和所有的输入都有关。</p>
<h2 id="Interruption：取消执行中的工作通常立即发送出去"><a href="#Interruption：取消执行中的工作通常立即发送出去" class="headerlink" title="Interruption：取消执行中的工作通常立即发送出去"></a>Interruption：取消执行中的工作通常立即发送出去</h2><p>当事件流需要取消处理就会发送一个Interrupted事件。Interruption的状态介于成功和失败之间–操作并没有成功，也没有结束，也不代表着失败。</p>
<p>大部分的操作符会立即响应interruption，但是也有一些例外。比如，flatten操作符就会忽略在内部producer发出的Interrupted事件，因为内部的某个操作取消不应该取消整个单元的工作。</p>
<p>RAC会在disposal之前发送一个Interrupted事件，但是也可以手动发送。另外，自定义的操作符要保证会继续传送interruption给观察者。</p>
<h2 id="事件是线性发送的"><a href="#事件是线性发送的" class="headerlink" title="事件是线性发送的"></a>事件是线性发送的</h2><p>RAC保证所有在流里的事件都是线性依次发送。换句话说，观察者不会同时收到多个事件，即便事件是多线程同步产生的。</p>
<h2 id="事件不能递归"><a href="#事件不能递归" class="headerlink" title="事件不能递归"></a>事件不能递归</h2><p>就像RAC保证事件不会被同时接收到，它也保证不会递归的接收事件。因此，操作者和观察者没必要考虑重入。</p>
<p>如果正在处理一个从某信号发送的事件，此时一个事件通过另一个线程从这个信号发出，会导致死锁。这是因为递归信号通常是程序员的失误，确定性的死锁比不确定的资源竞争好。</p>
<p>如果确实需要一个递归的信号，递归的事件需要时间迁移，用一个操作符比如delay保证不会从一个正在运行的事件处理程序中发出。</p>
<h2 id="事件默认是同步发送的"><a href="#事件默认是同步发送的" class="headerlink" title="事件默认是同步发送的"></a>事件默认是同步发送的</h2><p>RAC不会隐式的引入并发和异步。操作者也许会接收一个scheduler，但是他们必须显式的被用户调用。</p>
<p>一个信号或者producer发送信号默认都是同步的，因为着当他们发送时观察者马上被调起。<br>这和NSNotificationCenter和UIControl事件的分发很像。</p>
<h1 id="Signal的规范"><a href="#Signal的规范" class="headerlink" title="Signal的规范"></a>Signal的规范</h1><p>一个信号是始终打开的流，流按照事件的规范。信号是一个引用类型。</p>
<p>因为每个信号都有自己的身份，换句话说，每个信号都有自己的生命周期，最终通常会终止。一旦被终止，信号不能被重启。</p>
<h2 id="信号一被实例化就开始工作"><a href="#信号一被实例化就开始工作" class="headerlink" title="信号一被实例化就开始工作"></a>信号一被实例化就开始工作</h2><p>Signal.init立即就会执行传递过来的闭包。意味着副作用可能在初始化器返回前就发生。</p>
<p>也可能在初始化器返回前就发送事件。然而，因为这个时候任何观察者都不能被添加，这个时候发出的事件都是不会被接收到。</p>
<h2 id="观察一个信号不会有副作用"><a href="#观察一个信号不会有副作用" class="headerlink" title="观察一个信号不会有副作用"></a>观察一个信号不会有副作用</h2><p> 当一个信号的观察者被添加或者被移除时，和信号关联的操作不会被启动或者停止。所以观察方法不会有副作用。</p>
<p>一个信号的副作用只能通过一个终结事件来停止。</p>
<h2 id="同一个信号的所有观察者同时按照相同顺序接收到事件"><a href="#同一个信号的所有观察者同时按照相同顺序接收到事件" class="headerlink" title="同一个信号的所有观察者同时按照相同顺序接收到事件"></a>同一个信号的所有观察者同时按照相同顺序接收到事件</h2><p>因为观察行为不会有副作用，一个信号不会为不同的观察者自定义不同的事件。<br>当一个事件从信号发出时，它会被同步的分发给所有观察者，这个机制和NSNotificationCenter发送通知有点像。</p>
<p>换句话说，不存在不同的观察者对应不同的事件流。所有的观察者看到的都是同一个事件流。</p>
<p>这条规则只有一种意外情况：在一个信号终止后添加一个观察者会产生一个Interrupted事件发送给这个观察者。</p>
<h2 id="信号会一直被保持直到所有观察者都被释放"><a href="#信号会一直被保持直到所有观察者都被释放" class="headerlink" title="信号会一直被保持直到所有观察者都被释放"></a>信号会一直被保持直到所有观察者都被释放</h2><p>即使信号源（caller）不再有一个指针指向信号（does not maintain a reference）：</p>
<p>Signal.init创建的信号会一直存在直到生成器闭包（generator closure）释放了作为参数的观察者<br>Signal.pipe创建的信号会一直存在直到它返回的观察者被释放<br>这保证了和信号关联的长耗时的工作不会被提前销毁。</p>
<p>注意一下，可以在收到终结事件收到前提前释放信号。但是应该避免这么做，这会导致内存泄露，但是有时为了让终结不可用会这么做。</p>
<h2 id="终止事件清除信号相关的资源"><a href="#终止事件清除信号相关的资源" class="headerlink" title="终止事件清除信号相关的资源"></a>终止事件清除信号相关的资源</h2><p>当一个终结事件从信号发出，所有的观察者都会被释放，所有用于产生事件的资源都应该被清除。</p>
<p>最简单的保证正确的清楚资源是利用生成器闭包（generator closure）返回的disposable，当终止发生时它会被处理。disposable要负责释放资源，关闭文件句柄，取消网络请求，或者其他任何和工作想关联的东西。</p>
<h2 id="SignalProducer的规范"><a href="#SignalProducer的规范" class="headerlink" title="SignalProducer的规范"></a>SignalProducer的规范</h2><p>一个信号生产者（signal producer）就像一份创造信号的食谱。信号生产者不会自己开始工作，在生成一个信号后开始工作。</p>
<p>信号生产者就是一份声明怎么创建信号，是值类型，所以没有内存管理的事情要担心。</p>
<h2 id="信号生成者根据创建信号的要求开始工作"><a href="#信号生成者根据创建信号的要求开始工作" class="headerlink" title="信号生成者根据创建信号的要求开始工作"></a>信号生成者根据创建信号的要求开始工作</h2><p> start和  startWithSignal方法会都会生成一个信号（隐式和显式）。在初始化信号后，传递给 SignalProducer.init的闭包会被执行,在有观察者添加后开启事件流。</p>
<p>虽然生产者自己不负责工作的执行，但是我们也会说“starting”和“canceling” 一个生产者。这两个词指产生一个要开始工作的信号，和释放那个信号以停止工作。</p>
<p>一个生产者可以被开始很多次，相关联的工作也会被执行同样多次。</p>
<h2 id="每个生产的信号可能在不同的时间发送不同的事件"><a href="#每个生产的信号可能在不同的时间发送不同的事件" class="headerlink" title="每个生产的信号可能在不同的时间发送不同的事件"></a>每个生产的信号可能在不同的时间发送不同的事件</h2><p>因为信号生产者根据需要开始工作，所以可能每次执行相关的观察者会不同，这些观察者可能接收到完全不同的事件顺序。</p>
<p>换句话说，每次生产者启动后生成的事件可能完全不同或者顺序完全不同。</p>
<p>尽管如此，每个信号生产者的每次执行后会按照事件的规范。（ReactiveCocoa 4 文档翻译:设计指南(一)：事件的规范）</p>
<h2 id="信号的操作符可以在迁移后使用在信号生产者上"><a href="#信号的操作符可以在迁移后使用在信号生产者上" class="headerlink" title="信号的操作符可以在迁移后使用在信号生产者上"></a>信号的操作符可以在迁移后使用在信号生产者上</h2><p>因为信号和信号生产者的紧密关系，利用 lift方法将使用在信号上的操作符向上迁移就可以使用在信号生产者上。</p>
<p> lift会将这个操作符的行为使用在每个信号生成者启动后产生的信号上。</p>
<h2 id="释放一个生产的信号会中断（interrupt）它"><a href="#释放一个生产的信号会中断（interrupt）它" class="headerlink" title="释放一个生产的信号会中断（interrupt）它"></a>释放一个生产的信号会中断（interrupt）它</h2><p>当一个信号生产者通过  startor  startWithSignal方法启动, 一个  Disposable会被自动创建并且传回。</p>
<p>释放它会中断信号生产者，从而取消未执行的工作并且发送一个Interrupted事件给所有观察者，也会释放所有在 SignalProducer.init时被添加进 CompositeDisposable的东西。<br>注意释放一个生产的信号不会影响到其他有这个信号生产者产生的信号。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/21/ReactiveCocoa（RAC）最新版使用参考/" itemprop="url">
                  ReactiveCocoa（RAC）最新版使用参考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-21T17:44:36+08:00" content="2016-04-21">
              2016-04-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/21/ReactiveCocoa（RAC）最新版使用参考/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/21/ReactiveCocoa（RAC）最新版使用参考/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h1><ol>
<li>面向过程：处理事情以过程为核心，一步一步的实现。比如C语言。</li>
<li>面向对象：（面向对象编程(Object Oriented Programming,OOP,面向对象程序设计)是一种计算机编程架构）万物皆对象。比如OC。</li>
<li>链式编程思想：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)比如我们使用的一些第三方框架</li>
<li>响应式编程思想：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。</li>
<li>函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。</li>
</ol>
<h1 id="ReactiveCocoa作用和导入使用"><a href="#ReactiveCocoa作用和导入使用" class="headerlink" title="ReactiveCocoa作用和导入使用"></a>ReactiveCocoa作用和导入使用</h1><blockquote>
<p>ReactiveCocoa（RAC）是什么？<br>ReactiveCocoa（其简称为 RAC）是由 Github 开源的一个应用于 iOS 和 OS X 开发的新框架。RAC 具有函数式编程和响应式编程的特性。它主要吸取了 .Net 的 Reactive Extensions 的设计和实现。<br>ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中高聚合，低耦合的思想。作为一个iOS开发者，你写的每一行代码几乎都是在响应某个事件，例如按钮的点击，收到网络消息，属性的变化（通过KVO）或者用户位置的变化（通过CoreLocation）。但是这些事件都用不同的方式来处理，比如action、delegate、KVO、callback等。ReactiveCocoa为事件定义了一个标准接口，从而可以使用一些基本工具来更容易的连接、过滤和组合。</p>
</blockquote>
<h3 id="我们采用cocoapods配置ReactiveCocoa"><a href="#我们采用cocoapods配置ReactiveCocoa" class="headerlink" title="我们采用cocoapods配置ReactiveCocoa"></a>我们采用cocoapods配置ReactiveCocoa</h3><blockquote>
<p>切记ReactiveCocoa 4.10 最低部署版本为iOS8,笔者亲测<br>platform:ios,’8.0’<br>use_frameworks!<br>pod ‘ReactiveCocoa’, ‘~&gt; 4.1.0’</p>
</blockquote>
<h3 id="这样，我就成功导入ReactiveCocoa了！"><a href="#这样，我就成功导入ReactiveCocoa了！" class="headerlink" title="这样，我就成功导入ReactiveCocoa了！"></a>这样，我就成功导入ReactiveCocoa了！</h3><hr>
<blockquote>
<p>本文是本人整合市面上一些主流说法，以及大量参考了原作者官方文档，感谢前辈们让我们站在巨人的肩膀上！</p>
</blockquote>
<p>同时也希望转载本文的读者能够注明[转载出处]:(wengwenyu.com)<a href="wengwenyu.com">wengwenyu.com</a>，我会在文章最末处注明参考文献，同时会附上本人示例工程。</p>
<hr>
<h1 id="常言道：知其然，知其所以然"><a href="#常言道：知其然，知其所以然" class="headerlink" title="常言道：知其然，知其所以然"></a>常言道：知其然，知其所以然</h1><h2 id="函数式响应式编程"><a href="#函数式响应式编程" class="headerlink" title="函数式响应式编程"></a>函数式响应式编程</h2><blockquote>
<p>函数式响应式，顾明思义（函数式+响应式） ，是函数和响应式的结晶</p>
</blockquote>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>笔者摘抄<a href="wengwenyu.com">维基百科</a>里面的内容给读者介绍一下什么是响应式编程:</p>
<blockquote>
<p>在计算机中，响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。(节选自维基百科)<br>举个简单的例子：</p>
</blockquote>
<p>sum = a + b ;</p>
<p>sum的值受到 a  和  b 的影响，即a的值改变了，或者是b的值改变了，或者是a和b的值都改变了，sum的值都会收到影响。简而言之，sum的值会一直受到a和b的影响，一直会等于a+b的和并且永远都是这样如果你没有去改变这个规律的话。</p>
<h3 id="函数式-更强调程序执行的结果而非过程"><a href="#函数式-更强调程序执行的结果而非过程" class="headerlink" title="函数式(更强调程序执行的结果而非过程)"></a>函数式(更强调程序执行的结果而非过程)</h3><p>笔者同样引自[维基百科]wengwenyu.com的一段内容:</p>
<blockquote>
<p>函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p>
</blockquote>
<h2 id="ReactiveCocoa之扬帆起航！"><a href="#ReactiveCocoa之扬帆起航！" class="headerlink" title="ReactiveCocoa之扬帆起航！"></a>ReactiveCocoa之扬帆起航！</h2><blockquote>
<p>流和序列（流是值的序列化抽象）</p>
</blockquote>
<p>你可以认为流是一个水管，而值是水管里面的水，值从管道的一端流入，另外一端流出，当值从管道的另一端流出的时候，我们可以读取过去所有的值，甚至是刚刚进入管道的值(即当前值)。</p>
<blockquote>
<p>*重点:我们需要重点说一下信号，信号是另外一种类型的流。与序列流相反，信号是push-driven的。新的值能够通过管道发布但不能像pull-driven一样在管道中获取，他们所抽象出来的数据会在未来的某个时间传送过来。</p>
</blockquote>
<p>这里需要理解两个概念:pull-driven和push-driven.</p>
<blockquote>
<p>Push-driven : 在创建信号的时候，信号不会被立即赋值，之后才会被赋值(举个栗子：网络请求回来的结果或者是任意的用户输入的结果)<br>Pull-driven : 在创建信号的同时序列中的值就会被确定下来，我们可以从流中一个个地查询值。<br>信号发送三种类型的值：Next Values代表了下一个发送到管道内的值。Error Value代表signal无法成功完成,一般很少见。Completion Values代表signal成功完成。一个事情响应中，一个signal(信号)发送了一个Error value或者一个Completion Value后，就不会再发送任何其他的value. 错误或者成功将只会发送其中一个，绝不会有两个同时发送的情况！</p>
<p>信号是ReactiveCocoa的核心组件之一。ReactiveCocoa为UIKit的每一个控件内置了一套信号选择器。例如，UITextField就有一个rac_textSignal,UITextField中每一次按键的响应都会通过它发送出去。信号也可以被链接(链式调用)和转化。通过映射或者过滤一个流得到的新的流也可以随后被映射、被过滤，进行所有你能想到的各种操作；</p>
<p>与此同时我们还需要理解信号的订阅：信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。（关于冷热信号我们接下来会详细阐述）</p>
</blockquote>
<h3 id="如何订阅信号：调用信号RACSignal的subscribeNext就能订阅"><a href="#如何订阅信号：调用信号RACSignal的subscribeNext就能订阅" class="headerlink" title="如何订阅信号：调用信号RACSignal的subscribeNext就能订阅"></a>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅</h3><h4 id="UIButton案例"><a href="#UIButton案例" class="headerlink" title="UIButton案例"></a>UIButton案例</h4><pre><code>
//我来搞一个返回按钮masonry + ReactiveCocoa
self.button = [UIButton buttonWithType:UIButtonTypeCustom];
[self.button setTitle:@"返回" forState:UIControlStateNormal];
self.button.backgroundColor = [UIColor redColor];
[self.view addSubview:self.button];



[self.button mas_makeConstraints:^(MASConstraintMaker *make) {
make.left.mas_equalTo(self.view).offset(20);
make.top.mas_equalTo(self.view).offset(20);
make.width.mas_equalTo(100);
make.height.mas_equalTo(44);
}];


[[self.button rac_signalForControlEvents:UIControlEventTouchUpInside]subscribeNext:^(id x) {
NSLog(@"按钮被点击");
}];

</code></pre>

<h4 id="UITextFiled案例"><a href="#UITextFiled案例" class="headerlink" title="UITextFiled案例"></a>UITextFiled案例</h4><pre><code>
_tf = [[UITextField alloc]init];
_tf.backgroundColor = [UIColor greenColor];
[self.view addSubview:_tf];
[_tf mas_makeConstraints:^(MASConstraintMaker *make) {

make.leftMargin.mas_equalTo(20);
make.topMargin.mas_equalTo(100);
make.width.mas_equalTo(100);
make.height.mas_equalTo(44);
}];

/**
有没有觉得这样去写 很爽
*/
[_tf.rac_textSignal subscribeNext:^(id x) {

NSLog(@"%@",x);
}];

</code></pre>



<h4 id="UIDatePicker示例"><a href="#UIDatePicker示例" class="headerlink" title="UIDatePicker示例"></a>UIDatePicker示例</h4><pre><code>
[[date rac_signalForControlEvents:UIControlEventValueChanged]subscribeNext:^(UIDatePicker * x) {
NSLog(@"%@",x.date);
}];
</code></pre>






<h3 id="状态推导"><a href="#状态推导" class="headerlink" title="状态推导"></a>状态推导</h3><blockquote>
<p>状态推导是ReactiveCocoa的另一个核心组件。这里并非指类的某个属性(设置一个新的值就代表状态发生了改变那样)，这里我们指的是把属性抽象为流.假设我们的视图是用来创建账户的，我们只允许包含有’@’字符的Email地址，当且仅当，输入的用户名有效时使按键可用，同时我们也希望通过TextField中Text的颜色给用户提供反馈。</p>
<h4 id="按钮状态和信号绑定"><a href="#按钮状态和信号绑定" class="headerlink" title="按钮状态和信号绑定"></a>按钮状态和信号绑定</h4><p><pre><code><br>RACSignal * validEmailSignal = [self.tf.rac_textSignal map:^id(id value) {<br>return @([value rangeOfString:@”@”].location != NSNotFound);<br>}];</code></pre></p>
</blockquote>
<p>RAC(self.button,enabled) = validEmailSignal;</p>
<p>RAC(self.tf,textColor) = [validEmailSignal map:^id(id value) {<br>if ([value integerValue]) {<br>return  [UIColor greenColor];<br>}else{</p>
<p>return  [UIColor redColor];</p>
<p>}<br>}];</p>
<p></p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><blockquote>
<p>实际上button的rac_command可以为我们监控enabled属性 比之前使用的方法更好</p>
</blockquote>
<ul>
<li><p>指令，RACCommand类的代表，创建并订阅动作的信号响应，可以很容易地实现一些用户与应用交互时的边界效果。</p>
</li>
<li><p>指令(行为触发的)通常是UI驱动的，比如按键的点击。指令也可以通过信号自动禁用，这种禁用状态呈现在UI上就是禁用与该指令相关联的任何操作。</p>
</li>
<li>当你想要一次用户交互发送一个信号来响应的时候指令就很有用。</li>
</ul>
<h2 id="热信号与冷信号"><a href="#热信号与冷信号" class="headerlink" title="热信号与冷信号"></a>热信号与冷信号</h2><p>信号是典型的懒鬼，除非有人订阅他们，他们是不会启动并发送的。每增加一个订阅，它们都会重复地多发送一个信号。鉴于用户操作的琐碎性，这种设计是可接受的。实际上，在ReactiveCocoa的命名法则中，这种信号被称为’冷(信号)’。</p>
<p>有的时候我们希望让信号立即工作(不需要中间这么繁琐的设置),ReactiveCocoa中称为’热(信号)’。这种信号用的非常少。</p>
<h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><blockquote>
<p>组播是用语多个订阅者共享一个订阅信号的术语,默认的情况下，信号是冷的。有时候，我们不希望一个冷信号在每一次被订阅时工作。这通常在边界效应、订阅所要执行的任务代价昂贵或者只能以其他方式在适当的时间执行时有这种需求。这时网络请求浮现在脑海中。。。</p>
</blockquote>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/20/hexo安装和使用/" itemprop="url">
                  hexo安装和使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-20T20:03:14+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/20/hexo安装和使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/20/hexo安装和使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>安装git(如果你安装了xcode就说明你默认自带git)</li>
<li>安装node.js(去官网下载安装包即可)</li>
<li>安装hexo</li>
</ol>
<blockquote>
<p>npm install -g hexo<br>卸载的话，自然是把上面命令中的install替换成uninstall即可执行卸载。</p>
</blockquote>
<p>4.创建hexo文件夹</p>
<blockquote>
<p>hexo init +你的用来存放hexo的文件夹的名字</p>
</blockquote>
<p>5.安装依赖包</p>
<blockquote>
<p>npm install</p>
</blockquote>
<p>6.生成静态页面和启动本地服务器</p>
<blockquote>
<p>hexo g<br>hexo s</p>
</blockquote>
<p>7.部署远程博客<br>（1）编辑D:\hexo目录下的配置文件_config.yml,在最下面输入以下内容，注意把里面的wengwenyu替换成你的用户名</p>
<p>deploy:<br>type: git<br>repository: <a href="https://github.com/wengwenyu/wengwenyu.git" target="_blank" rel="external">https://github.com/wengwenyu/wengwenyu.git</a>   hub.io.git<br>branch: master<br>（2）部署远程博客，输入以下命令</p>
<blockquote>
<p>hexo g<br>hexo d</p>
</blockquote>
<p>出现下面的提示表示部署成功</p>
<p>INFO Deploy done: git</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/19/cocoaPods安装流程/" itemprop="url">
                  cocoaPods安装流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-19T12:24:13+08:00" content="2016-04-19">
              2016-04-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/19/cocoaPods安装流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/19/cocoaPods安装流程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h1>1.移除现有Ruby默认源    因为我们身处于大天朝<br></h1><p></p>
<h5>gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a><br></h5><br><h1>2.使用新的源<br></h1><br><h5>gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a><br></h5><br><h1>3.验证新源是否替换成功<br></h1><br><h5>gem sources –l<br></h5><br><h1>4.安装CocoaPods<br></h1><br><h5>sudo gem install cocoapods（苹果旧系统）<br></h5><br><h5>sudo gem install -n /usr/local/bin cocoapods（上面一行不行就下面一行）<br></h5><br><h5>pod setup<br><br>这一步宇哥等待了10分钟，也许网络原因，也许，是红杏出不了天朝的【墙】啊<br></h5><br><h1>5.更新gem<br></h1><br><h5>sudo gem update –system<br></h5><br><footer>配置提示</footer><br><h5>platform:ios, ‘7.0’<br></h5>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/18/将来的你/" itemprop="url">
                  将来的你
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-18T18:57:34+08:00" content="2016-04-18">
              2016-04-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/18/将来的你/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/18/将来的你/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
              <!-- 标签别名 -->
<blockquote class="blockquote-center"><p>将来的你，一定会感谢现在拼命的自己</p>
</blockquote>
<p><img src="http://cexxz.img47.wal8.com/img47/543451_20160418123551/146096881062.jpg"></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/18/第一篇文章/" itemprop="url">
                  我的私人领域开通拉
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-18T11:55:56+08:00" content="2016-04-18">
              2016-04-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/18/第一篇文章/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/18/第一篇文章/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: 写</p>
<h3 id="打开本地静态网页"><a href="#打开本地静态网页" class="headerlink" title="打开本地静态网页"></a>打开本地静态网页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: 本地</p>
<h3 id="创建静态网页"><a href="#创建静态网页" class="headerlink" title="创建静态网页"></a>创建静态网页</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: 静态网页</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: 上传</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/05/20/我是外星人/" itemprop="url">
                  我是外星人
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-05-20T20:10:46+08:00" content="2014-05-20">
              2014-05-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/05/20/我是外星人/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/20/我是外星人/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>你好陌生人</h1>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://cexxz.img47.wal8.com/img47/543451_20160418123551/146095697081.jpg"
               alt="翁闻宇" />
          <p class="site-author-name" itemprop="name">翁闻宇</p>
          <p class="site-description motion-element" itemprop="description">如果世界变了，别忘了天空最初的颜色</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">翁闻宇</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"wengwenyu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
